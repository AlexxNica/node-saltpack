// Generated by IcedCoffeeScript 108.0.11
(function() {
  var DecryptStream, EncryptStream, NaClDecryptStream, NaClEncryptStream, armor, header, msgpack, nacl, nonce, noop, payload, saltpack_block_len, stream,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  stream = require('keybase-chunk-stream');

  nacl = require('keybase-nacl');

  armor = require('node-armor-x');

  msgpack = require('msgpack-lite');

  payload = require('./payload.iced');

  header = require('./header.iced');

  nonce = require('./nonce.iced');

  saltpack_block_len = Math.pow(1024, 2);

  noop = function() {};

  exports.NaClEncryptStream = NaClEncryptStream = (function(_super) {
    __extends(NaClEncryptStream, _super);

    NaClEncryptStream.prototype._encrypt = function(chunk) {
      var payload_list;
      payload_list = payload.generate_encryption_payload_packet(this.encryptor, chunk, this.block_num, this.header_hash, this.mac_keys);
      ++this.block_num;
      return payload_list;
    };

    function NaClEncryptStream(pk, sk, recipients) {
      this.recipients = recipients;
      this._encrypt = __bind(this._encrypt, this);
      this.encryptor = nacl.alloc({
        force_js: false
      });
      this.encryptor.publicKey = pk;
      this.encryptor.secretKey = sk;
      this.header_written = false;
      this.header_hash = null;
      this.mac_keys = null;
      this.block_num = 0;
      NaClEncryptStream.__super__.constructor.call(this, this._encrypt, saltpack_block_len, true, {
        writableObjectMode: false,
        readableObjectMode: true
      });
    }

    NaClEncryptStream.prototype._transform = function(chunk, encoding, cb) {
      var header_intermediate, payload_key, _ref;
      if (this.header_written) {
        return NaClEncryptStream.__super__._transform.call(this, chunk, encoding, cb);
      } else {
        _ref = header.generate_encryption_header_packet(this.encryptor, this.recipients), header_intermediate = _ref.header_intermediate, this.header_hash = _ref.header_hash, this.mac_keys = _ref.mac_keys, payload_key = _ref.payload_key;
        this.encryptor.secretKey = payload_key;
        this.push(msgpack.encode(header_intermediate));
        this.header_written = true;
        return cb();
      }
    };

    NaClEncryptStream.prototype._flush = function(cb) {
      NaClEncryptStream.__super__._flush.call(this, noop);
      this.push(this._encrypt(new Buffer('')));
      return cb();
    };

    return NaClEncryptStream;

  })(stream.ChunkStream);

  NaClDecryptStream = (function(_super) {
    var decrypt;

    __extends(NaClDecryptStream, _super);

    decrypt = function(chunk) {
      var ciphertext;
      ciphertext = parse_payload_packet(chunk, this.header_hash, this.mac_key, 'foo', this.block_num);
      payload = this.decryptor.secretbox_open({
        ciphertext: ciphertext,
        nonce: nonce.nonceForChunkSecretBox(this.block_num)
      });
      ++this.block_num;
      return payload;
    };

    function NaClDecryptStream(pk, sk) {
      this.decryptor = nacl.alloc({
        force_js: false
      });
      this.decryptor.publicKey = pk;
      this.decryptor.secretKey = sk;
      this.header_read = false;
      this.header_hash = null;
      this.mac_key = null;
      this.auth_index = null;
      this.block_num = 0;
      NaClDecryptStream.__super__.constructor.call(this, decrypt, saltpack_block_len, true, {
        writableObjectMode: false,
        readableObjectMode: true
      });
    }

    NaClDecryptStream.prototype._transform = function(chunk, encoding, cb) {
      var payload_key, _, _ref;
      if (this.header_read) {
        return NaClDecryptStream.__super__._transform.call(this, chunk, encoding, cb);
      } else {
        _ref = header.parse_encryption_header_packet(this.decryptor, chunk), _ = _ref._, this.header_hash = _ref.header_hash, payload_key = _ref.payload_key, _ = _ref._, this.mac_key = _ref.mac_key, this.auth_index = _ref.auth_index;
        this.decryptor.secretKey = payload_key;
        this.header_read = true;
        return cb();
      }
    };

    return NaClDecryptStream;

  })(stream.ChunkStream);

  exports.EncryptStream = EncryptStream = (function() {
    function EncryptStream(pk, sk, recipients, do_armoring) {
      this.nacl_stream = new NaClEncryptStream(pk, sk, recipients);
      this.pack_stream = msgpack.createEncodeStream();
      this.last_stream = this.pack_stream;
      this.nacl_stream.pipe(this.pack_stream);
      if (do_armoring) {
        this.armor_stream = new armor.stream.StreamEncoder(armor.encoding.b62.encoding);
        this.pack_stream.pipe(this.armor_stream);
        this.last_stream = this.armor_stream;
      }
    }

    EncryptStream.prototype.pipe = function(dest) {
      return this.last_stream.pipe(dest);
    };

    EncryptStream.prototype.read = function(size) {
      return this.last_stream.read(size);
    };

    EncryptStream.prototype.write = function(chunk) {
      return this.nacl_stream.write(chunk);
    };

    EncryptStream.prototype.end = function() {
      return this.nacl_stream.end();
    };

    return EncryptStream;

  })();

  exports.DecryptStream = DecryptStream = (function() {
    function DecryptStream(pk, sk, do_armoring) {
      this.unpack_stream = msgpack.createDecodeStream();
      this.first_stream = this.unpack_stream;
      if (do_armoring) {
        this.armor_stream = new armor.stream.StreamDecoder(armor.encoding.b62.encoding);
        this.armor_stream.pipe(this.unpack_stream);
        this.first_stream = this.armor_stream;
      }
      this.nacl_stream = new NaClDecryptStream(pk, sk);
      this.unpack_stream.pipe(this.nacl_stream);
    }

    DecryptStream.prototype.pipe = function(dest) {
      return this.nacl_stream.pipe(dest);
    };

    DecryptStream.prototype.read = function(size) {
      return this.nacl_stream.read(size);
    };

    DecryptStream.prototype.write = function(chunk) {
      return this.first_stream.write(chunk);
    };

    DecryptStream.prototype.end = function() {
      return this.first_stream.end();
    };

    return DecryptStream;

  })();

}).call(this);
