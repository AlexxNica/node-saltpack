// Generated by IcedCoffeeScript 108.0.11
(function() {
  var compute_authenticator, crypto, msgpack, nonce, step1, util;

  crypto = require('crypto');

  msgpack = require('purepack');

  nonce = require('./nonce');

  util = require('./util');

  compute_authenticator = function(hash, key) {
    var hmac;
    hmac = crypto.createHmac('sha512', key);
    hmac.update(hash);
    return hmac.digest().slice(0, 32);
  };

  step1 = function(header_hash, block_num, payload_secretbox) {
    var crypto_hash, step1_cat, step1_hash;
    step1_cat = Buffer.concat([header_hash, nonce.nonceForChunkSecretBox(block_num), payload_secretbox]);
    crypto_hash = crypto.createHash('sha512');
    crypto_hash.update(step1_cat);
    step1_hash = crypto_hash.digest();
    return step1_hash;
  };

  exports.generate_encryption_payload_packet = function(_arg) {
    var authenticator, authenticators, block_num, header_hash, mac_key, mac_keys, payload_encryptor, payload_secretbox, plaintext, step1_hash, _i, _len;
    payload_encryptor = _arg.payload_encryptor, plaintext = _arg.plaintext, block_num = _arg.block_num, header_hash = _arg.header_hash, mac_keys = _arg.mac_keys;
    payload_secretbox = payload_encryptor.secretbox({
      plaintext: plaintext,
      nonce: nonce.nonceForChunkSecretBox(block_num)
    });
    step1_hash = step1(header_hash, block_num, payload_secretbox);
    authenticators = [];
    for (_i = 0, _len = mac_keys.length; _i < _len; _i++) {
      mac_key = mac_keys[_i];
      authenticator = compute_authenticator(step1_hash, mac_key);
      authenticators.push(authenticator);
    }
    return [authenticators, payload_secretbox];
  };

  exports.parse_encryption_payload_packet = function(_arg) {
    var block_num, computed_authenticator, header_hash, mac_key, payload, payload_decryptor, payload_list, recipient_index, step1_hash;
    payload_decryptor = _arg.payload_decryptor, payload_list = _arg.payload_list, block_num = _arg.block_num, header_hash = _arg.header_hash, mac_key = _arg.mac_key, recipient_index = _arg.recipient_index;
    step1_hash = step1(header_hash, block_num, payload_list[1]);
    computed_authenticator = compute_authenticator(step1_hash, mac_key);
    if (!util.bufeq_secure(computed_authenticator, payload_list[0][recipient_index])) {
      throw new Error('Integrity check failed!');
    }
    payload = payload_decryptor.secretbox_open({
      ciphertext: payload_list[1],
      nonce: nonce.nonceForChunkSecretBox(block_num)
    });
    return payload;
  };

}).call(this);
