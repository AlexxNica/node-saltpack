// Generated by IcedCoffeeScript 108.0.11
(function() {
  var attached_sign_mode, compute_mac_key, createHash, crypto, crypto_onetimeauth_BYTES, crypto_secretkey_BYTES, current_major, current_minor, detached_sign_mode, encryption_mode, msgpack, nonce, prng;

  prng = require('crypto').prng;

  createHash = require('crypto').createHash;

  msgpack = require('msgpack-lite');

  crypto = require('keybase-nacl');

  nonce = require('./nonce.iced');

  encryption_mode = 0;

  attached_sign_mode = 1;

  detached_sign_mode = 2;

  current_major = 1;

  current_minor = 0;

  crypto_onetimeauth_BYTES = 32;

  crypto_secretkey_BYTES = 32;

  compute_mac_key = function(encryptor, header_hash, pubkey) {
    var mac_box, zero_bytes;
    zero_bytes = Buffer.alloc(crypto_onetimeauth_BYTES);
    mac_box = encryptor.encrypt({
      plaintext: zero_bytes,
      nonce: nonce.nonceForMACKeyBox(header_hash),
      pubkey: pubkey
    });
    return mac_box.slice(-crypto_onetimeauth_BYTES);
  };

  exports.generate_encryption_header_packet = function(encryptor, recipients) {
    var crypto_hash, ephemeral_encryptor, header_hash, header_intermediate, header_list, header_packet, mac_keys, payload_encryptor, payload_key, rec_pair, rec_payload, rec_pubkey, recipients_list, sender_sbox, _i, _j, _len, _len1;
    header_list = [];
    header_list.push('saltpack');
    header_list.push([current_major, current_minor]);
    header_list.push(encryption_mode);
    payload_encryptor = crypto.alloc({
      force_js: true
    });
    payload_key = prng(crypto_secretkey_BYTES);
    payload_encryptor.secretKey = payload_key;
    ephemeral_encryptor = crypto.alloc({
      force_js: true
    });
    ephemeral_encryptor.genBoxPair();
    header_list.push(ephemeral_encryptor.publicKey);
    sender_sbox = payload_encryptor.secretbox({
      plaintext: encryptor.publicKey,
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    header_list.push(sender_sbox);
    recipients_list = [];
    for (_i = 0, _len = recipients.length; _i < _len; _i++) {
      rec_pubkey = recipients[_i];
      rec_pair = [];
      rec_pair.push(rec_pubkey);
      rec_payload = ephemeral_encryptor.encrypt({
        plaintext: payload_key,
        nonce: nonce.nonceForPayloadKeyBox(),
        pubkey: rec_pubkey
      });
      rec_pair.push(rec_payload);
      recipients_list.push(rec_pair);
    }
    header_list.push(recipients_list);
    crypto_hash = createHash('sha512');
    header_intermediate = msgpack.encode(header_list);
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    header_packet = msgpack.encode(header_intermediate);
    mac_keys = [];
    for (_j = 0, _len1 = recipients.length; _j < _len1; _j++) {
      rec_pubkey = recipients[_j];
      mac_keys.push(compute_mac_key(encryptor, header_hash, rec_pubkey));
    }
    return {
      header_list: header_list,
      header_hash: header_hash,
      header_packet: header_packet,
      mac_keys: mac_keys
    };
  };

  exports.parse_encryption_header_packet = function(decryptor, header_packet) {
    var crypto_hash, ephemeral, error, format, found, header_hash, header_intermediate, header_list, mac_key, major, minor, mode, payload_decryptor, payload_key, rec_pair, recipients, secret, sender, sender_pubkey, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    crypto_hash = createHash('sha512');
    header_intermediate = msgpack.decode(header_packet);
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    header_list = msgpack.decode(header_intermediate);
    format = header_list[0], (_ref = header_list[1], major = _ref[0], minor = _ref[1]), mode = header_list[2], ephemeral = header_list[3], sender = header_list[4], recipients = header_list[5];
    if (format !== 'saltpack') {
      throw new Error("wrong format " + format);
    }
    if (major !== current_major) {
      throw new Error("wrong version number " + major + "." + minor);
    }
    if (mode !== encryption_mode) {
      throw new Error("packet wasn't meant for decryption, found mode " + mode);
    }
    secret = decryptor.box_beforenm({
      pubkey: ephemeral,
      seckey: decryptor.secretKey
    });
    found = false;
    payload_key = new Buffer([]);
    _ref1 = header_list[5];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      rec_pair = _ref1[_i];
      if (rec_pair[0] === decryptor.publicKey) {
        payload_key = decryptor.box_open_afternm({
          ciphertext: rec_pair[1],
          nonce: nonce.nonceForPayloadKeyBox(),
          secret: secret
        });
        found = true;
      }
    }
    if (!found) {
      _ref2 = header_list[5];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        rec_pair = _ref2[_j];
        try {
          payload_key = decryptor.box_open_afternm({
            ciphertext: rec_pair[1],
            nonce: nonce.nonceForPayloadKeyBox(),
            secret: secret
          });
        } catch (_error) {
          error = _error;
          continue;
        }
      }
    }
    if (payload_key.length === 0) {
      throw new Error('You are not a recipient!');
    }
    payload_decryptor = crypto.alloc({
      force_js: false
    });
    payload_decryptor.secretKey = payload_key;
    sender_pubkey = payload_decryptor.secretbox_open({
      ciphertext: header_list[4],
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    mac_key = compute_mac_key(decryptor, header_hash, sender_pubkey);
    return {
      header_hash: header_hash,
      header_list: header_list,
      payload_key: payload_key,
      mac_key: mac_key
    };
  };

}).call(this);
