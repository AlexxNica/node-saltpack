// Generated by IcedCoffeeScript 108.0.11
(function() {
  var compute_mac_key, createHash, crypto, msgpack, nonce, prng;

  prng = require('crypto').prng;

  createHash = require('crypto').createHash;

  msgpack = require('purepack');

  crypto = require('keybase-nacl');

  nonce = require('./nonce.iced');

  compute_mac_key = function(encryptor, header_hash, pubkey) {
    var mac_box, zero_bytes;
    zero_bytes = Buffer.alloc(32);
    mac_box = encryptor.encrypt({
      plaintext: zero_bytes,
      nonce: nonce.nonceForMACKeyBox(header_hash),
      pubkey: pubkey
    });
    return mac_box.slice(-32);
  };

  exports.generate_encryption_header_packet = function(encryptor, recipients) {
    var crypto_hash, ephemeral_encryptor, header_hash, header_intermediate, header_list, header_packet, mac_keys, mode, payload_encryptor, payload_key, rec_pair, rec_payload, rec_pubkey, recipients_list, sender_sbox, _i, _j, _len, _len1;
    mode = 0;
    header_list = [];
    header_list.push('saltpack');
    header_list.push([1, 0]);
    header_list.push(mode);
    payload_encryptor = crypto.alloc({
      force_js: true
    });
    payload_key = prng(32);
    payload_encryptor.secretKey = payload_key;
    ephemeral_encryptor = crypto.alloc({
      force_js: true
    });
    ephemeral_encryptor.genBoxPair();
    header_list.push(ephemeral_encryptor.publicKey);
    sender_sbox = payload_encryptor.secretbox({
      plaintext: encryptor.publicKey,
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    header_list.push(sender_sbox);
    recipients_list = [];
    for (_i = 0, _len = recipients.length; _i < _len; _i++) {
      rec_pubkey = recipients[_i];
      rec_pair = [];
      rec_pair.push(rec_pubkey);
      rec_payload = ephemeral_encryptor.encrypt({
        plaintext: payload_key,
        nonce: nonce.nonceForPayloadKeyBox(),
        pubkey: rec_pubkey
      });
      rec_pair.push(rec_payload);
      recipients_list.push(rec_pair);
    }
    header_list.push(recipients_list);
    crypto_hash = createHash('sha512');
    header_intermediate = msgpack.pack(header_list);
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    header_packet = msgpack.pack(header_intermediate);
    mac_keys = [];
    for (_j = 0, _len1 = recipients.length; _j < _len1; _j++) {
      rec_pubkey = recipients[_j];
      mac_keys.push(compute_mac_key(encryptor, header_hash, rec_pubkey));
    }
    return {
      header_packet: header_packet,
      mac_keys: mac_keys
    };
  };

  exports.parse_encryption_header_packet = function(decryptor, header_packet) {
    var crypto_hash, error, found, header_hash, header_intermediate, header_list, mac_key, payload_decryptor, payload_key, rec_pair, secret, sender_pubkey, _i, _j, _len, _len1, _ref, _ref1;
    crypto_hash = createHash('sha512');
    header_intermediate = msgpack.unpack(header_packet);
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    header_list = msgpack.unpack(header_intermediate);
    if (header_list[0] !== 'saltpack') {
      throw new Error("wrong format " + header_list[0]);
    }
    if (header_list[1][0] !== 1 || header_list[1][1] !== 0) {
      throw new Error("wrong version number " + header_list[1][0] + "." + header_list[1][1]);
    }
    if (header_list[2] !== 0) {
      throw new Error("packet wasn't meant for decryption, found mode " + header_list[2]);
    }
    secret = decryptor.box_beforenm({
      pubkey: header_list[3],
      seckey: decryptor.secretKey
    });
    found = false;
    payload_key = new Buffer([]);
    _ref = header_list[5];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rec_pair = _ref[_i];
      if (rec_pair[0] === decryptor.publicKey) {
        payload_key = decryptor.box_open_afternm({
          ciphertext: rec_pair[1],
          nonce: nonce.nonceForPayloadKeyBox(),
          secret: secret
        });
        found = true;
      }
    }
    if (!found) {
      _ref1 = header_list[5];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        rec_pair = _ref1[_j];
        try {
          payload_key = decryptor.box_open_afternm({
            ciphertext: rec_pair[1],
            nonce: nonce.nonceForPayloadKeyBox(),
            secret: secret
          });
        } catch (_error) {
          error = _error;
          continue;
        }
      }
    }
    if (payload_key.length === 0) {
      throw new Error('You are not a recipient!');
    }
    payload_decryptor = crypto.alloc({
      force_js: false
    });
    payload_decryptor.secretKey = payload_key;
    sender_pubkey = payload_decryptor.secretbox_open({
      ciphertext: header_list[4],
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    mac_key = compute_mac_key(decryptor, header_hash, sender_pubkey);
    return {
      header_packet: header_packet,
      mac_key: mac_key
    };
  };

}).call(this);
