// Generated by IcedCoffeeScript 108.0.11
(function() {
  var DeformatStream, FormatStream, chars_per_word, newline, noop, punctuation, space, stream, util, words_per_line,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  stream = require('keybase-chunk-stream');

  util = require('./util');

  space = new Buffer(' ');

  newline = new Buffer('\n');

  punctuation = new Buffer('.');

  words_per_line = 200;

  chars_per_word = 15;

  noop = function() {};

  exports.FormatStream = FormatStream = (function(_super) {
    __extends(FormatStream, _super);

    FormatStream.prototype._format = function(chunk) {
      var res;
      if (chunk.length < this.block_size) {
        return chunk;
      }
      res = new Buffer('');
      if (!this._header_written) {
        res = Buffer.concat([this._header, punctuation, space]);
        this._header_written = true;
      }
      this._word_count++;
      if (this._word_count !== 200) {
        res = Buffer.concat([res, chunk, space]);
      } else {
        res = Buffer.concat([res, chunk, newline]);
        this._word_count = 0;
      }
      return res;
    };

    FormatStream.prototype._flush = function(cb) {
      FormatStream.__super__._flush.call(this, noop);
      this.push(Buffer.concat([punctuation, space, this._footer, punctuation]));
      return cb();
    };

    function FormatStream(_arg) {
      var brand, _brand;
      brand = _arg.brand;
      if (brand != null) {
        _brand = brand;
      } else {
        _brand = 'KEYBASE';
      }
      this._header = new Buffer("BEGIN" + space + _brand + space + "SALTPACK" + space + "ENCRYPTED" + space + "MESSAGE");
      this._footer = new Buffer("END" + space + _brand + space + "SALTPACK" + space + "ENCRYPTED" + space + "MESSAGE");
      this._header_written = false;
      this._word_count = 0;
      FormatStream.__super__.constructor.call(this, {
        transform_func: this._format,
        block_size: chars_per_word,
        exact_chunking: true,
        writableObjectMode: false,
        readableObjectMode: false
      });
    }

    return FormatStream;

  })(stream.ChunkStream);

  exports.DeformatStream = DeformatStream = (function(_super) {
    var _body_mode, _footer_mode, _header_mode, _strip, _strip_re;

    __extends(DeformatStream, _super);

    _header_mode = 0;

    _body_mode = 1;

    _footer_mode = 2;

    _strip_re = /[>\n\r\t ]/g;

    _strip = function(chunk) {
      return chunk = new Buffer(chunk.toString().replace(_strip_re, ""));
    };

    DeformatStream.prototype._deformat = function(chunk) {
      var after_period, footer, header, index, re, ret;
      switch (this._mode) {
        case _header_mode:
          index = chunk.indexOf(punctuation[0]);
          if (index > 0) {
            after_period = chunk.slice(index + 1);
            header = Buffer.concat([this._partial, chunk.slice(0, index)]);
            this._partial = new Buffer('');
            re = /[>\n\r\t ]*BEGIN[>\n\r\t ]+([a-zA-Z0-9]+)?[>\n\r\t ]+SALTPACK[>\n\r\t ]+(ENCRYPTED[>\n\r\t ]+MESSAGE)|(SIGNED[>\n\r\t ]+MESSAGE)|(DETACHED[>\n\r\t ]+SIGNATURE)[>\n\r\t ]*/;
            if (!re.test(header)) {
              console.log("HEADER " + header);
              throw new Error("Header failed to verify!");
            }
            this._header = _strip(header);
            this._mode = _body_mode;
            return _strip(after_period);
          } else {
            this._partial = Buffer.concat([this._partial, chunk]);
            return new Buffer('');
          }
          break;
        case _body_mode:
          index = chunk.indexOf(punctuation[0]);
          if (index === -1) {
            return _strip(chunk);
          } else {
            ret = _strip(chunk.slice(0, index));
            this._partial = chunk.slice(index + punctuation.length + space.length);
            this._mode = _footer_mode;
            return ret;
          }
          break;
        case _footer_mode:
          index = chunk.indexOf(punctuation[0]);
          if (index > 0) {
            footer = Buffer.concat([this._partial, chunk]);
            if (_strip(footer) !== Buffer.concat([new Buffer('END'), _strip(this._header.slice(6))])) {
              throw new Error("Footer failed to verify!");
            }
            return new Buffer('');
          } else {
            this._partial = Buffer.concat([this._partial, chunk]);
            return new Buffer('');
          }
      }
    };

    function DeformatStream(_arg) {
      var brand, _brand;
      brand = _arg.brand;
      if (brand != null) {
        _brand = brand;
      } else {
        _brand = 'KEYBASE';
      }
      this._header = new Buffer('');
      this._mode = _header_mode;
      this._partial = new Buffer('');
      DeformatStream.__super__.constructor.call(this, {
        transform_func: this._deformat,
        block_size: 2048,
        exact_chunking: false,
        writableObjectMode: false,
        readableObjectMode: false
      });
    }

    return DeformatStream;

  })(stream.ChunkStream);

}).call(this);
